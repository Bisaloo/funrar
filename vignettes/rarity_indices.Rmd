---
title: "How to use funrar, an example with plant communities dataset."
author: "Denelle Pierre & Greni\u00e9 Matthias"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use funrar, an example with plant communities dataset.}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

The idea of Functional Rarity is to measure two components of the rarity of a species (or an individual). Indeed, in community ecology, people are generally interested in the rarity of a species in terms of abundances. A species with a low abundance will be considered as rare. From a functional ecology perspective, this does not take into consideration the "role" that a given species plays in the ecosystem, its particular niche. A framework is being developed of various indices to characterize how this function could be rare locally or regionally

In their article, Violle et al. (2016) introduced 4 indices to compute functional rarity indices. ???`funrar` package enables ecologists to compute them on any dataset.

# Framework

The following figure show the 4 aspects covered by the metrics. Rarity is thus considered at local and regional scales and also from abundance and functional point of views. The name of the package functions are written underneath metrics' names.

![Rarity indices and corresponding functions.](F:/PIERRE_DENELLE/Functional_rarity/outlier_scheme.png)

# Dataset example

To show how the package works, We are using a dataset describing the distribution of 82 species of Alpine plants in 75 sites. This dataset was collected by Choler et al. and is presented in the following article.

Species traits and environmental variables are also available.

```{r}

data("aravo", package = "ade4")

```


# Functional rarity indices 

## Inputs of functions

For each metric, the package includes two versions, depending on the input. 
Ecologist usually have to deal with site-species matrix, containing sites names as rows, species in columns and either abundances or presence/absence data (see example datasets in `vegan` or `ade4` packages for example). Thus, this matrix is needed as an input for each simple function.


```{r}

# Site-species matrix stored in aravo$spe
mat <- as.matrix(aravo$spe)

mat[1:5, 1:5]

```

In other cases, users can have a stacked data.frame containing columns for sites, species and abundances. This format can be used to have a better overview of the data and can be perceived as more intuitive. The package contains for each metric another function called `metricname_stack()` function that can take these stacked data.frames as inputs.

`funrar` package includes two functions to go from one format to the other: `matrix_to_tidy()` and `tidy_to_matrix()`

```{r}

dat <- matrix_to_tidy(mat, "value", "site", "species")
head(dat)

# The reverse function is provided and gives the same original matrix
identical(as.numeric(tidy_to_matrix(dat, "site", "species", "value")), as.numeric(mat))

```

The package is also able to deal with big matrices by using a sparse matrix approach. For more details, see `sparse_matrices` vignette.

## Indices

### Distance matrix computation

The indices rely on the computation of a distance matrix. It represents the functional distance between two species given a particular set of traits. From a species traits matrix you can easily compute a distance matrix using function `compute_dist_matrix()`.

In order to compute distance matrix, species names must be specified as **rownames** in the traits table. And they will be named similarly in the distance matrix. Species names must be characters and not factors.

The function relies on the `daisy()` function from package `cluster` and the default metric is Gower's distance to take into account ordinal, categorical and binary traits.

```{r}

tra <- aravo$traits[, c("Height", "SLA", "N_mass")]
head(tra)
# Package loading
library(outlieR)

dist_mat <- compute_dist_matrix(tra)
dist_mat[1:5, 1:5]

```

### Distinctiveness computation

#### Formula

The distinctiveness measures how a species is locally functionally rare, in comparison with the other species of community. Each species (or individual) in each community will get a distinctiveness value. Distinctiveness values range from 0 to 1. A 0 value indicates that the focal species is not locally functionally distant from the other and conversely.

From given functional distances, it is computed as such:

$$
D_i = \frac{\sum_{\substack{j = 1, \\
                            i \neq j
                            }}^{N} d_{ij}}{N-1},
$$

with $D_i$ distinctiveness of species $i$, $d_{ij}$ the functional distance between species $i$ and species $j$, $N$ the number of species present in considered community.

When weighted by abundances the formula becomes:

$$
D_i = \frac{\sum_{\substack{j = 1, \\
                            i \neq j
                            }}^{N} d_{ij}\times A_j}{\sum_{\substack{j = 1, \\
                            i \neq j
                            }}^{N} A_j},
$$
with the same terms as above, and $A_j$ the relative abundance of species $j$ in percent, in the community.


#### Computation with site-species matrix

Using `outlieR` distinctiveness values can be computed using function `distinctiveness()`:

```{r distinctivenessComputation}

# Compute distinctiveness for each species on each site
di = distinctiveness(pres_matrix = mat,  # The site x species table
                     dist_matrix = dist_mat)  # Functional Distance matrix

di[1:5, 1:5]

```

The syntax for `distinctiveness()` is first the table and then the distance matrix. The function returns a site-species matrix filled with `Di` values, i.e. the species distinctiveness in each species per site combination.

#### Computation with stacked data.frame

Using `outlieR` distinctiveness values can be computed using function `table_distinctiveness()`:

```{r computeDi}

# Species should be character
dat$species = as.character(dat$species)

# Compute distinctiveness for each species on each site
di_df = table_distinctiveness(com_table = dat,  # The site x species table
                              sp_col = "species",  # Name of the species column
                              com = "site",  # Name of the community column
                              abund = NULL,  # Relative abundances column (facultative)
                              dist_matrix = dist_mat)  # Functional Distance matrix

head(di_df)

```

The syntax for `table_distinctiveness()` is first the table, then the name of the species column, then the name of the community column, then eventually the name of the relative abundance column and finally the distance matrix. The function add a `Di` column giving the species distinctiveness in each species per site combination.

For abundance weighted distinctiveness you need to have a column containing relative abundances in your data frame as such:

```{r abundDi}

di_df = table_distinctiveness(dat, "species", "site", "value", dist_mat)

head(di_df)

```

### Scarcity

#### Formula

The scarcity measures how a species is locally abundant, in comparison with the other species of community. Each species (or individual) in each community will get a scarcity value. Scarcity values range from 0 to 1. A 0 value indicates that the focal species is locally abundant and conversely.

$$
S_i = \exp(-NA_i\log2),
$$

with $S_i$ the scarcity of species $i$, $N$ the number of species in the local community, $A_i$ the relative abundance (in percent) of species $i$ in the community.


#### Computation

With `outlieR` it can be computed with `scarcity()` function with a syntax analog to `distinctiveness()`

```{r scarcityComp}

si = scarcity(pres_matrix = mat)

si[1:5, 1:5]

```

```{r siComp}

si_df = table_scarcity(dat, "species", "site", "value")

head(si_df)

```

### Uniqueness

#### Formula

The uniqueness measures how a species is functionally rare at regional scale. Each species (or individual) of the species pool will get a uniqueness value. Uniqueness values range from 0 to 1. A 0 value indicates that the focal species shares the exact same traits than other species in the pool and conversely.

$$
U_i = \text{min}(d_{ij}), \forall j \in [1, N_R], j \neq i,
$$

with $U_i$ the uniqueness of species $i$, $d_{ij}$ the functional distance between species $i$ and species $j$, $N_R$ the number of species in the regional pool.

#### Computation

`uniqueness()` follows a similar syntax, but beware that given community table and distance matrix should be given out of **regional species pool**. And the syntax is also similar:

```{r uniqComp}

ui = uniqueness(mat, dist_mat)

head(ui)
```

```{r uiComp}

ui_df = table_uniqueness(dat, "species", dist_mat)

head(ui_df)
dim(ui_df[!duplicated(ui_df$species), ])

```

### Restrictedness

#### Formula

The restrictedness measures how a species is regionally rare. The following function thus represents species' occupancy of the set of communities. Each species (or individual) of the species pool will get a restrictedness value. Restrictedness values range from 0 to 1. A 0 value indicates that the focal species is present in all the sites and conversely.

$$
R_i = 1 - N_i/N_tot
$$

with $R_i$ the restrictedness of species $i$, $N_i$ the number of sites where species $i$ is found and $N_tot$ the total number of sites.

#### Computation

```{r}
ri = restrictedness(mat)

head(ri)
```

```{r}

# Species should be character
dat$site = as.character(dat$site)

ri_df = table_restrictedness(dat, "site", "species")

head(ri_df)

```

### funrar

This function computes at the same time the four metrics introduced above.

```{r}


all_ind = funrar(mat, dist_mat, rel_abund = TRUE)

str(all_ind)

identical(all_ind$Ui, ui)
identical(all_ind$Di, di)
identical(all_ind$Ri, ri)
identical(all_ind$Si, si)

```

# Plots

In this section, some ideas to plot your results are presented.

```{r}

library(ggplot2)
library(RColorBrewer)

#quant <- quantile(species_agg$di_mean, probs = seq(0, 1, 0.10))
#labels_quant <- paste(names(quant)[-length(quant)], names(quant)[-1], sep="-")

#di_density <- data.frame(density(species_agg$di_mean)[c("x", "y")])
#di_density <- filter(di_density, x >= quant[[1]] & x <= quant[[length(quant)]])
#di_density$quant <- cut(di_density$x, breaks = quant)   
#quant <- quantile(species_agg$di_mean, probs = seq(0, 1, 0.10))
#labels_quant <- paste(names(quant)[-length(quant)], names(quant)[-1], sep="-")

#di_dens <- ggplot(data = di_density, aes(x = x, y = y)) +
#geom_area(aes(fill = quant)) +
#scale_fill_brewer(palette = "RdYlBu", labels = labels_quant, name = "Quantile") +
#geom_line(size = 1) +
#xlab("Di mean per species") +
#ylab("Frequency") +
# ggtitle("All traits") +
# theme_classic()

```

# References

Choler, P. (2005) Consistent shifts in Alpine plant traits along a mesotopographical gradient. Arctic,
Antarctic, and Alpine Research, 37,444-453.




